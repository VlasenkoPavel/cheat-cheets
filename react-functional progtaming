42
Более сложные
функции, называемые функциями высшего порядка, могли манипулировать функ-
циями и использовать их в качестве либо аргументов, либо результатов, либо и того
и другого.

43
JavaScript поддерживает функциональное программирование, так как его функ-
ции относятся к объектам первого класса. Это значит следующее: функции могут
делать то же самое, что и переменные. 

45
Функциональное программирование является частью более обширной парадиг-
мы: декларативного программирования. Оно представляет собой отдельный стиль
программирования. При его соблюдении приложения структурированы таким
образом: описание того, что должно случиться, приоритетнее определения того,
как это должно случиться.

47
основные концепции функционального программирования: неизменяемость, чистоту,
преобразование данных, функции высшего порядка и рекурсию

50
Чистой функцией называют функцию, которая возвращает значение, вычисляемое
на основе ее аргументов. Чистые функции получают как минимум один аргумент
и всегда возвращают значение или другую функцию. Эти функции не имеют по-
бочных эффектов, не устанавливают значений глобальных переменных и не из-
меняют ничего, что относится к состоянию приложения. Они рассматривают свои
аргументы в качестве неизменяемых данных.

52
При написании функций старайтесь следовать трем правилам.
1. Функция должна получать как минимум один аргумент.
2. Функция должна возвращать значение или другую функцию.
3. Функция не должна вносить какие-либо изменения в переданные ей аргументы.

Для профессионального овладения функциональным JavaScript нужно освоить две ключевые функции: 
Array.map и Array.reduce.

53
предикат - функция, которая всегда возвращает булево значение

При решении задачи по удалению элемента из массива нужно пользоваться функ-
цией Array.filter, а не функцией Array.pop или Array.splice, так как Array.filter
не вносит в данные никаких изменений.

//заметка 
get методы должны возвращаьт копии атрибутов

58 
про hash

60
Каррирование — функциональная технология, для которой привлекается исполь-
зование функций высшего порядка. При каррировании практикуется удержание
отдельных значений, необходимых для завершения операции, до тех пор пока чуть
позже не сможет быть предоставлено все остальное. Это достигается путем при-
менения функции, возвращающей другую функцию, называемую каррированной.

63
Рекурсия является весьма эффективной и легко реализуемой функциональной тех-
нологией. Используйте ее вместо организации циклов везде, где только возможно.

Функции в JavaScript могут быть составлены в цепочку
с помощью системы записи, применяющей точки, чтобы действие выполнялось
над значением, возвращенным предыдущей функцией.

можно воспользоваться для составления композиций из функций и помещения
их в более крупные функции.

const both = compose(
    civilianHours,
    appendAMPM
)

both(new Date())

const compose = (...fns) =>
    (arg) => fns.reduce(
        (composed, f) => f(composed),
        arg
)

65
1. Сохраняйте неизменяемость данных.
2. Сохраняйте чистоту функций, пусть они получают как минимум один аргумент
и возвращают данные или другую функцию.
3. Используйте рекурсию вместо циклов (везде, где только возможно).

68
const display = target => time => target(time)

84
Функциональные компоненты, не имеющие состояния, являются функциями,
а не объектами, так что у них нет области видимости this.

85  // {items} вместо props.items
const IngredientsList = ({items}) =>
	React.createElement("ul", {className: "ingredients"},
		items.map((ingredient, i) =>
			React.createElement("li", { key: i }, ingredient)
		)
	)
86
Для того чтобы работа React занимала приемлемый отрезок времени, метод
ReactDOM.render должен делать свою работу весьма рациональным образом,
и он вполне успешно справляется с этой задачей. Вместо опустошения и рекон-
струирования всей DOM метод оставляет текущую модель на месте и применя-
ет минимальный объем изменений, необходимый для трансформации DOM.

88
Вставка элемента в DOM — одна из самых затратных операций API DOM, которая вы-
полняется довольно медленно. По сравнению с этим обновление элементов, уже
находящихся на месте, происходит гораздо быстрее, чем вставка новых.

91
виртуальная DOM — набор инструкций, которым React следует при создании и 
обновлении пользовательского интерфейса. Эти инструкции состоят из объектов 
JavaScript, называемых элементами React.

const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!'
  }
};

В JSX тип элемента указывается с помощью тега. Его атрибуты представляют
свойства. Дочерние элементы к создаваемому элементу могут добавляться между
открывающим и закрывающим тегами.

93
className вместо class
<h1>{this.props.title}</h1>
<input type="checkbox" defaultChecked={false} />

JSX — не что иное, как JavaScript, поэтому код JSX можно непосредственно вклю-
чать в функции JavaScript.

<ul>
	{this.props.ingredients.map((ingredient, i) =>
		<li key={i}>{ingredient}</li>
	)}
</ul>

Код JSX выглядит понятым и легко читаемым, но не может интерпретиро-
ваться браузером (Babel).

94
Процесс такого преобразования называется транспиляцией, и именно
для его осуществления предназначен Babel ( https://babeljs.io/ ).

95
Для начала можно воспользоваться самым простым из них, включив ссылку 
на транспилятор babel-core непосредственно в свой HTML, что приведет 
к транспиляции любого кода в блоках сценария, имеющих тип text/babel.

98
const Menu = ({ title, recipes }) => (
	<article>
		<header>
			<h1>{title}</h1>
		</header>
		<div className="recipes">
			{recipes.map((recipe, i) =>
				<Recipe key={i} {...recipe} />
			)}
		</div>
	</article>
)

ввод имен влокальную область видимости с помощью деструктуризации
replace(/ /g, "-")    //  ??? / /g

вместо
const Menu = (props) =>
	<article>
		<header>
			<h1>{props.title}</h1>
		</header>
{props.recipes.map((recipe, i) =>
	<Recipe key={i} name={recipe.name} ingredients={recipe.ingredients} steps={recipe.steps} />
)}

102
про babel, babel-preset-env и стадии

103
Все теги script делают HTTP-запросы, каждый из которых влечет крайне невыгодные задержки.

109
Присваивание window.React значения React дает библиотеке React в браузере гло-
бальную область видимости. Тем самым гарантируется работоспособность всех
вызовов функции React.createElement .

115
Еще одним привлекательным свойством сборщика Webpack является его спо-
собность включать код CSS в файл с тем же пакетом, в котором находится код
JavaScript. Это позволяет пользователям загружать единый файл, содержащий весь
необходимый приложению код CSS и JavaScript.
Код CSS может быть включен в пакет с помощью инструкций import . Они указывают 
сборщику на необходимость включить в пакет файлы CSS, связанные с модулем
JavaScript

119
В React имеется автоматическая встроенная проверка свойств ( https://facebook.github.io/
react/docs/typechecking-with-proptypes.html ) на типы переменных, сведения о которой
приведены в табл. 6.1. Свойство элемента propTypes.

123
getDefaultProps() - задается свойства по умолчанию

126 
propTypes и getDefaultProps в новом синтаксисе (классы и фк не имеющие состояния) 
определяются за вне определения класса, для фк можно установить дефолтные через аргументы

127
В последних предложениях по спецификации ECMAScript появилась еще одна альтернативная 
возможность: поля классов и статические свойства (сlass fields & static properties).
Статические свойства класса позволяют инкапсулировать propTypes и  defaultProps
внутри объявления класса. Инициализаторы свойств также предоставляют возмож-
ность инкапсуляции и более понятный синтаксис

128
html атрибуты оформляются как свойства

129-130
Поле ref является идентификатором того, что React использует для
ссылки элементы DOM. Создание ref -атрибутов _title и  _color для каждого 
элемента ввода данных input означает возможность получения доступа к этим
элементам с помощью выражений this.refs_title или this.refs_color
(??? без точки??? this.refs._title).
legasy APIб вмест онего рекомендуется использовать callback pattern или createRef API.
https://reactjs.org/docs/refs-and-the-dom.html#callback-refs
https://reactjs.org/docs/refs-and-the-dom.html#creating-refs
